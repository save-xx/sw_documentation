{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"CNNDetection/","title":"CNNDetection","text":"<p>The <code>CNNDetection</code> class is an optional sensor plugin designed to emulate the output of a Convolutional Neural Network (CNN) detector. It simulates the detection and localization of neighboring agents by estimating their positions and headings. This plugin operates as a global sensor, meaning it has access to the full environment state to generate its output.</p> <p>SwarmSwIM.sensors.CNNDetection (rnd = None, visibility_model = None)</p>"},{"location":"CNNDetection/#parameters","title":"Parameters","text":"<ul> <li>rnd: (numpy.random.generator or None) Default None<ul> <li>Initializes the random number generator. If set to <code>None</code>, a new generator will be created. Otherwise, the provided generator will be used. The intended usage is to inherit the generator from the <code>Simulator</code>, ensuring consistent and reproducible behavior across components.</li> </ul> </li> </ul> <p>(deprectated remove) - visibility_model: (string) Default None      * Define model used to determine the distance-based probability of detection. <code>None</code>, and <code>linear</code>. In  <code>None</code> all detection are succesfull if contained in the defined Field of View. In <code>linear</code> the probability function is defined as a splitwise linear fuction of the distance. </p>"},{"location":"CNNDetection/#methods","title":"Methods","text":"<ul> <li><code>__call__</code>(Simulation)  -&gt;  list [string] <ul> <li>Calculates the detections of all agents involved in the simulations, outputs the lists of the agents names that recived an updated in the call. The input is the <code>Simulation</code> instance. Note that the method already optimizes on the udate rate, so that the relative pose clculations are only executed as needed.  This method alters and stores the relative informations in each <code>Agent</code> instance withing the <code>NNDetector</code> atturibute (see Example).</li> </ul> </li> </ul>"},{"location":"CNNDetection/#agentnndetector","title":"<code>Agent.NNDetector</code>","text":"<p>The <code>Agent.NNDetector</code> is an optional <code>Agent</code> attrubute which is manipulated by the <code>CNNDetection</code> in order to store the detection informations. Specifically it is a dictionary with the following proprieties:  - a special key <code>time_lapsed</code> stores the lapsed time since the last detection activation.  - a key with the name of each agent sucessfully detected in the last detection structures as a list of three flloats:     - Radial relative distance [m]     - Planar angle Alpha [degree]. Angle on the horizontal plane, with x axis (0 degree) the heading of the observing Agent.     - Elevation angle Beta [degree]. Angle measured from the horizontal plane</p> <p>The values presented already implement the measuraments noises as defined in the Agent XML description.</p>"},{"location":"CNNDetection/#examples","title":"Examples","text":"<pre><code># Import The Simulator from SwarmSwIM\nfrom SwarmSwIM import Simulator, Agent\nfrom SwarmSwIM import CNNDetection\n\n# Generate a simulation object, set the time step to 1/30 sec (30 Hz)\nTIME_STEP = 1.0 / 30\nsim = Simulator(TIME_STEP)\n# Initiate detection\nDetection = CNNDetection()\n\nfirst_agent_name = sim.agents[0].name\n\n# Run 100 seconds of simulation\nfor ist in range(3000):\n    # advance the simulation foward of one TIME_STEP seconds\n    sim.tick()\n    detection_upd_names = Detection(sim)\n    # print resulting detection for the first agent, if it has recived an update\n    if first_agent_name in detection_upd_names:\n        new_detection = sim.agents[0].NNDetector\n        for key in new_detection:\n            if key=='time_lapsed': continue\n            print(f' time: {sim.time:.2f}', end=\"\")\n            print(f'    {key} : ',end=\"\") \n            print(f'[ dist: {new_detection[key][0]:.2f} ',end=\"\") \n            print(f'alpha: {new_detection[key][1]:.2f} ',end=\"\") \n            print(f'beta: {new_detection[key][2]:.2f} ]')\n</code></pre>"},{"location":"Home/","title":"SwarmSwIM wiki","text":"<p>Welcome to the SwarmSwIM Wiki</p>"},{"location":"Home/#getting-started","title":"Getting Started","text":"<ul> <li>Installation</li> <li>Create a new simulation</li> </ul>"},{"location":"Home/#useful-links","title":"Useful links:","text":"<ul> <li>Parameters: Description of the parameters and methods of the classes, and fuction of this package. </li> <li>setup XML files: Description of the files defining the simulation and agents charatersitics</li> </ul>"},{"location":"Parameters/","title":"Parameters","text":""},{"location":"Parameters/#attributes-and-methods","title":"Attributes and Methods","text":"<p>Description of the simulator classes and associated attributes and methods</p> <ul> <li>Simulator: Generate the core simulation.</li> <li>Agent: Generate an instance of a simulated agent. </li> </ul>"},{"location":"Plugin_template/","title":"Create a new Plugin","text":"<p>SwarmSwim is set to simplify and streamline the process of adding a new plugin to the simulator. In order to do so one should follow the template below:</p> <pre><code>\"\"\"SwarmSwIM Plugin template.\"\"\"\n# A baseline template to add new plugins to the SwarmSwIM simulator\n\nimport xml.etree.ElementTree as ET\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef activate_Plugin(simulation, sensor_name=\"default_name\", *args, **kwargs):\n    \"\"\"\n    User function to add the plugin to the simulator.\n    Takes an instance of the simulator and any number of arguments (as preferred)\n    \"\"\"\n    # Create an instance of the Plugin class\n    plugin_instance = Plugin(simulation, sensor_name, *args, **kwargs)\n\n    # Register the sensor in the simulation post-step call dictionary\n    simulation.plugins_calls_poststep[sensor_name] = plugin_instance\n\n    # or the pre-step call dictionary\n    # simulation.plugins_calls_prestep[sensor_name] = plugin_instance\n\n    # Optionally, return an handle to the user\n    return plugin_instance\n\n\nclass Plugin:\n    def __init__(self, simulation, plugin_name, *args, **kwargs):\n        \"\"\"Initialize the Plugin.\"\"\"\n\n        # Some common operation\n        self.sim = simulation\n        self.plugin_name = plugin_name\n\n        # create random seed\n        self.rnd = simulation.rnd.spawn(1)[0]\n\n        # path to the active simulation.xml file for parsing\n        sim_xml_path = simulation._simulation_filepath\n\n        # Extract parameters from XML\n        self._unpack_from_xml(plugin_name,  sim_xml_path)\n\n\n    def _unpack_from_xml(self, plugin_name,  sim_xml_path):\n        \"\"\"Store and extract data from an xml file, under sensor name.\"\"\"\n        tree = ET.parse(sim_xml_path)\n        root = tree.getroot()\n        root = root.find(plugin_name)\n        if root is None: \n            raise ValueError(f\"The XML does not contain a &lt;{plugin_name}&gt; element.\")\n        # Extract data\n        self.some_parameter = root.find(\"some_parameter\").text\n\n    def __call__(self):\n        \"\"\"Resolve plugin event at each simulation step\"\"\"\n\n        # =====================\n        # Plugin Logic\n        # Add here all the plugin logic and action\n        # remeber that you have access to the simulation state\n        # by referring self.sim, and each agent by self.sim.agents\n        # =====================\n\n        # store the latest output \n        self.result = \"Done\"\n        # Return the output of the event for the plugin\n        return self.result\n\n    def _bag(self)-&gt;dict:\n        \"\"\"Collect SQLite friendly output.\"\"\"\n\n        # =====================\n        # Return a dictionary or list of dictionaries that can be saved in a sql format.\n        # A dedicated page will be created for the plugin using the plugin name.\n        # Each list element adds a line in the log, multiple elements will add multiple\n        #  lines at each call.\n        # if [] is passed no line is added.\n        # =====================\n\n        sql_friendly_out = [{\"output\": self.result}]\n        return sql_friendly_out\n</code></pre>"},{"location":"Plugin_template/#explanation","title":"Explanation","text":""},{"location":"Plugin_template/#imports","title":"Imports","text":"<pre><code>import xml.etree.ElementTree as ET\nimport logging\n\nlogger = logging.getLogger(__name__)\n</code></pre> <p>Those are the minimum recommended inputs to be added. <code>xml</code> allows to parse the simulations and agents xml files, allowing to add and use new tags dedicated to the new plugin. The logging is the suggested way to add terminal output instead of <code>print()</code>.</p>"},{"location":"Plugin_template/#activate-the-plugin","title":"Activate the plugin","text":"<p>It is always recomended to create an activation function that starts the plugin and adds it to the simulation</p> <pre><code>def activate_Plugin(simulation, sensor_name=\"default_name\", *args, **kwargs):\n</code></pre> <p>As convetion, the function should be named activate_. Two required inputs should be set: <code>simulation</code>, as a reference the the simulation object, and <code>sensor_name</code> which should provide an unique key to identify the specific plugin. Beyond those an arbitrary number of parameters can be added as additional inputs as required. <pre><code>    # Create an instance of the Plugin class\n    plugin_instance = Plugin(simulation, sensor_name, *args, **kwargs)\n</code></pre> <p>In this line the <code>__init__</code> method of the Plugin class is called to create a new instance Succesively the instance must be passed to either <code>plugins_calls_poststep</code>, </p> <pre><code>    # Register the sensor in the simulation post-step call dictionary\n    simulation.plugins_calls_poststep[sensor_name] = plugin_instance\n</code></pre> <p>or <code>plugins_calls_prestep</code></p> <pre><code>    simulation.plugins_calls_prestep[sensor_name] = plugin_instance\n</code></pre> <p>The Prestep plugins are called before the update of the position of each agent due to control, while the poststep are called right after</p> <p>In some cases there are some methods of the plugin that should be accessible to the user: for example in the Acoustic plugin, the <code>AcousticChannel</code> plugin has a method <code>send</code> that is supposed to be used by the user/main script, to initiate acoustic communication.</p> <p>In those cases it is needed to expose a reference to the instance of the created plugin by returning it:</p> <pre><code>    # Optionally, return an handle to the user\n    return plugin_instance\n</code></pre>"},{"location":"Plugin_template/#__init__","title":"<code>__init__</code>","text":"<p>Some common practices during a plugin initialization</p> <pre><code>        # Some common operation\n        self.sim = simulation\n        self.plugin_name = plugin_name\n</code></pre> <p>Save the simulation instance and key name of the instance</p> <pre><code>        # create random seed\n        self.rnd = simulation.rnd.spawn(1)[0]\n</code></pre> <p>Avoid using <code>random</code> directely and refer to <code>self.rnd</code> as a spawn of a general random generator. This will preserve the full simulation repetability, when setting a global <code>seed</code>, while allowing to introduce pseudo-randomness to the plugin functions, if needed.</p> <pre><code>        # path to the active simulation.xml file for parsing\n        sim_xml_path = simulation._simulation_filepath\n\n        # Extract parameters from XML\n        self._unpack_from_xml(plugin_name,  sim_xml_path)\n</code></pre> <p>In order to extract data from the xml, one can directly refer to the full path saved internally in simulation. Below explained <code>_unpack_from_xml</code> to extract data from the simulation xml.</p>"},{"location":"Plugin_template/#unpack-from-xml","title":"Unpack from XML","text":"<p>Instead of passing every parameter at initialization, it is convinient to </p>"},{"location":"Simulator/","title":"Simulator","text":"<p>The <code>Simulator</code> class holds the primary tool to run a simulation. A single instance of the class is required for a simulation run. If the simulation is run with support of the UE5 Api of ROS bridging, The API or ROS bridge will handle the creation and setting of the <code>Simulation</code> class instance.</p> <p>SwarmSwIM.Simulator (timeSubdivision, sim_xml= \"simulation.xml\") Generate a simulation instance  </p>"},{"location":"Simulator/#parameters","title":"Parameters:","text":"<ul> <li>timeSubdivision:  (float) <ul> <li>Simulation interval in seconds (mandatory)  </li> </ul> </li> <li>sim_xml: (string) <ul> <li>Local or Global path to the xml file describing the simulation settings. Default is \"simulation.xml\" The setting provvides the addition of all Agents and all current effects. </li> </ul> </li> </ul>"},{"location":"Simulator/#attributes","title":"Attributes:","text":"<ul> <li>time: (float) <ul> <li>Current enlapsed time in seconds</li> </ul> </li> <li>rnd: (random.generator) <ul> <li>Random generator object associated to this specific simulation. </li> </ul> </li> <li>agents: (list of Agents) <ul> <li>List of the actively simulated agents objects</li> </ul> </li> <li>environment: (dictionary) <ul> <li>Collection of all current parameters. See Description avaiable option. This attribute is precompiled by the sim_xml file.</li> </ul> </li> <li>states: (dictionary name: np.array [x,y,z]) <ul> <li>Position of each agent in the simulation, collected by agent name as key </li> </ul> </li> </ul>"},{"location":"Simulator/#methods","title":"Methods:","text":"<ul> <li>add ( * args) -&gt; None: add one or more agents to the simulation. <ul> <li>args: one or more Agent object</li> </ul> </li> <li> <p>remove ( * args) -&gt; None: remove, if present, one or more agents to the simulation. </p> <ul> <li>args: one or more Agent object in agents.  </li> </ul> </li> <li> <p>tick( ) -&gt; None: move the simulation foward of the interval indicated in Dt</p> </li> <li> <p>rel_pos (Agent1, Agent2) -&gt; numpy.array: return the istantaneous position vector of Agent2 respect to Agent1.</p> <ul> <li>Agent1: Agent object</li> <li>Agent2: Agent object</li> </ul> </li> <li> <p>acoustic_range (Agent1, Agent2) -&gt; float: return the distance vector of Agent2 respect to Agent1, considering acoustic delay, including measurament errors.</p> <ul> <li>Agent1: Agent object (reciver)</li> <li>Agent2: Agent object (sender)</li> </ul> </li> <li> <p>OWTT_acoustic_range (Agent1, Agent2) -&gt; float: return the distance vector of Agent2 respect to Agent1, considering acoustic delay, , including measurament errors and One way clock drift error.</p> <ul> <li>Agent1, Agent object (reciver)</li> <li>Agent2: Agent object (sender)</li> </ul> </li> <li> <p>doppler (Agent1, Agent2, msg_dt= 1.0) -&gt; float: return the value of doppler velocity of Agent2 measured by agent1 on an incoming communication, including measurament errors.</p> <ul> <li>Agent1, Agent object (reciver)</li> <li>Agent2: Agent object (sender)</li> </ul> </li> </ul>"},{"location":"Simulator/#examples","title":"Examples","text":"<p>Following a minimalist example of the use of the <code>Simulator</code></p> <pre><code># Import The Simulator from SwarmSwIM\nfrom SwarmSwIM import Simulator\n\n# Generate a simulation object, set the time step to 1/30 sec (30 Hz)\nTIME_STEP = 1.0 / 30\nsim = Simulator(TIME_STEP)\n\n# Run 100 seconds of simulation\nfor ist in range(3000):\n    # Print current time of simulation evey 300 ist (10 sec)\n    if ist%300==0: print(f'{sim.time:.2f}')\n    # advance the simulation foward of one TIME_STEP seconds\n    sim.tick()\n</code></pre>"},{"location":"Simulator/#environment-attrubute-description","title":"<code>environment</code> attrubute description","text":"<p>The Simulator.environment attribute is a dictionary containing all the parameters that globally characterize the simulation. This attribute is fully populated during initialization and reflects the content of the simulation XML file. The preferred usage is to rely on the XML file for all parameter definitions. However, in certain scenarios, it may be useful to modify specific parameters during the mission. Below is a description of the individual elements:</p> <p><code>seed</code> Integer value used as seed for the random generator, if not defined an new random seed is used at each launch. Changes ater launch have no effect to the simulation. </p> <p><code>is_uniform_current</code> Boolean, enables uniform currents</p> <p><code>uniform_current</code> Value of uniform current. (see XML sim for usage)</p> <p><code>is_noise_currents</code> Boolean, enables noise currents</p> <p><code>noise_currents_freq</code>, <code>noise_currents_intensity</code> Value of noise current. (see XML sim for usage)</p> <p><code>is_vortex_currents</code> Boolean, enables large vortex currents</p> <p><code>vortex_currents_density</code>, <code>vortex_currents_intensity</code>  Value of vortex current. (see XML sim for usage)</p> <p><code>is_global_waves</code> Boolean, enables global waves (only time dependant) currents</p> <p><code>global_waves</code> Contains a list of dictionaries, each defining a global wave. Each of such dictionay is structured as follows: - <code>amplitude</code> - <code>frequency</code> - <code>direction</code> - <code>shift</code> Details on the Vaules contained under each key are explained in XML sim.</p> <p><code>is_local_waves</code> Boolean, enables local waves (time and space dependant) currents</p> <p><code>local_waves</code> Contains a list of dictionaries, each defining a local wave. Each of such dictionay is structured as follows: - <code>amplitude</code> - <code>wavelength</code> - <code>wavespeed</code> - <code>direction</code> - <code>shift</code></p> <p>Details on the Vaules contained under each key are explained in XML sim.</p>"},{"location":"XML_files/","title":"Setup Files","text":"<p>The simulators refers to 2 types of file for setting up the simulations. Thhose files contain all the paramenter and charateristics that allow to personalize each simulatation as needed. The files are written in XML format.  The philosofy is to allow the content of the file to coexisit whitin a standard URDF file, describing a specific robot  (agent) or simulation. Practical application of this principle is still ongoing. </p>"},{"location":"XML_files/#agent-description","title":"Agent Description","text":"<p>The agent description file defines the charateristics of a type of agent. It is worth nothing that multiple types can coexist in a simulation, and multiple instances of the same type are also allowed. The agent description file is defined either at the initialization of an <code>Agent</code> instance or within the Simulation description file. If not specified the default.xml description provvided in this package is used instead. </p> <p>The Agent Description file need to have the <code>.xml</code> termination and XML format. It is structured as follows: </p> <pre>\nagent.xml \n\u2514\u2500\u2500 data  \n    \u251c\u2500\u2500 sim_agent\n    \u2514\u2500\u2500 sensors \n        \u251c\u2500\u2500 NNDetector\n        \u2514\u2500\u2500 Acoustic_Ranging\n</pre> <p><code>sim_agent</code> contains all the primary information regarding the agent, while <code>sensors</code> contains plug-in pecific charaterization parameters. It is worth noting that <code>sensor</code> can be populated even if those sensors are not imported in the simulation.</p>"},{"location":"XML_files/#sim_agent-description","title":"<code>sim_agent</code> description","text":"<p>The following parameters are tunable in the sim_agent section:</p>"},{"location":"XML_files/#inertia-and-drag","title":"Inertia and Drag","text":"<ul> <li><code>mass</code>: Dry mass of the agent in Kg</li> <li><code>added_mass</code>: 2x2 matrix of the added mass of the agent, referring to the [u,v] linear &amp; planar DoF (see Handbook of Marine Craft, Thor I. Fossen). Note that the convention used if for the diagonal element to be defined positive.</li> <li><code>quadratic_damping</code>, <code>linear_damping</code>: 2x2 matrixes referring to the linear and quatratic dumping due to hydrodynamic drag. Following the formula.           Note that the convention used if for the diagonal element to be defined negative.</li> </ul>"},{"location":"XML_files/#controls","title":"Controls","text":"<p>Following the controls schemes that can be directly emulated and associated parameters. It is worth nothing that all parameters can be popoulated. The simulator will require the control specifi parameters to be defined. the control type can also be altered during the simulation, thus the associated parameters specified in the xml for the new type of control will be adapted.</p> <p>Control - Depth - <code>depth_control</code>: type of control used. Options are \"ideal\", \"step\", \"proportional\", \"heave\" - <code>step_depth</code>: speed of ascend/descend in m/s when \"step\" is selected - <code>proportional_depth</code>: value of propotional control when \"proportional\" is selected. Input is depth error [m], output is heave velocity [m/s]. - <code>heave_limit</code>: Upper-Lower limit of heave velocity [m/s], when \"proportional\" is selected.</p> <p>Control - Heading - <code>heading_control</code>: type of control used. Options are \"ideal\", \"step\", \"proportional\", \"yawrate\" - <code>step_depth</code>: speed of rotation yawrate in degrees/s when \"step\" is selected - <code>proportional_depth</code>: value of propotional control when \"proportional\" is selected. Input is heading error [degrees], assuming shortest direction, output is yawrate velocity [degree/s]. - <code>yawrate</code>: Upper-Lower limit of yawrate velocity [degree/s], when \"proportional\" is selected.</p> <p>Control - Planar - <code>planar_control</code>: type of control used. Options are \"ideal\", \"step\", \"local_velocity\",\"inertial_velocity\", \"local_forces\" - <code>step_planar</code>: planar speed in m/s when \"step\" is selected - <code>vel_limit</code>: 2-values, repesenting the surge and sway [u,v] velocity limit that the agent can reach. Applyed when \"local_velocity\" or \"inertial_velocity\" is selected.</p>"},{"location":"XML_files/#errornoises","title":"Error/Noises","text":"<p>Error and noises of the feedbacks expected in the control schemes can be emulated defining the error parameters. Such noises are modelled as gaussian noise and bias added to the ground truth value and then applied as input in the control scheme. A generic noise is defined as: - <code>e_&lt;input&gt;</code> = bias, standard deviation  </p> <p>The noises input that can be defined are: - <code>e_depth</code> - <code>e_heave</code> - <code>e_heading</code> - <code>e_yawrate</code> - <code>e_position</code> - <code>e_local_vel</code> - <code>e_inertial_vel</code> - <code>e_local_force</code></p> <p>The exception is <code>clock_drift</code> which is defined as the drift of the internal clock as PPM</p>"},{"location":"XML_files/#simulation-description","title":"Simulation Description","text":"<p>Each simulation is defined by a single simulation.xml file. The file is specified in the initialization of the <code>Simulation</code> class, and contains all the instructions to also initialize the agents. If not defined the simulation.xml file in this package is used as default.  </p> <p>The simulation description file need to have the <code>.xml</code> termination and XML format. It is structured as follows: </p> <pre>\nagent.xml \n\u2514\u2500\u2500 data  \n    \u251c\u2500\u2500 environment_setup\n    |   \u251c\u2500\u2500 global_waves\n    |   \u2514\u2500\u2500 local_waves\n    \u251c\u2500\u2500 agents \n    |   \u2514\u2500\u2500 agent_type\n    \u2514\u2500\u2500 seed\n</pre>"},{"location":"XML_files/#environment_setup-description","title":"<code>environment_setup</code> description","text":"<p>The <code>environment_setup</code> stores all data relative to current and current disturbances affecting the agents kinematics in the simulation.</p> <p>Uniform constant current - <code>uniform_current</code> :2-Values defining the current component Direction North-East, value in m/s</p> <p>Localized current disturbances and noise - <code>noise_currents</code> :2-Values Frequency (Hz), and max Intensity (m/s) of the localized current affecting each agent. At a rate driven by the Frequency, a disturbance vector of magnitude 0 to Intensity (Random Uniform) and random direction is generated. At each instance the noise disturbance affecting an agent is the linear interpolation of the last and next disturbance vector over time.</p> <ul> <li><code>vortex_currents</code>: 2-Values. Density and Intensity. Density is an integer determining the number of the vorticosity centers each 100 meter square, while intensity is the value intensity [m/s] associated to the votex. The effective modelling is explained in [link required].</li> </ul>"},{"location":"XML_files/#global_waves","title":"global_waves","text":"<p>Time dependand space independent sinusoidal wave-like disturbance. <code>global_waves</code> can contain a list of entries with arbitrary names. for conventions use <code>wave1</code>, <code>wave2</code> etc. Eack <code>wave</code> mush contain:</p> <ul> <li><code>amplitude</code>: Peak current intensity in m/s</li> <li><code>frequency</code>: Wave frequency, time based, expressed in Hz</li> <li><code>direction</code>: Direction in degrees of the current disturbance</li> <li><code>shift</code>: Offset on the wave timing, adimentional value between 0 and 2\u03c0</li> </ul>"},{"location":"XML_files/#local_waves","title":"local_waves","text":"<p>Time and space dependand sinusoidal wave-like disturbance. <code>local_waves</code> can contain a list of entries with arbitrary names. For conventions use <code>wave1</code>, <code>wave2</code> etc. Eack <code>wave</code> mush contain:</p> <ul> <li><code>amplitude</code>: Peak current intensity in m/s</li> <li><code>wavelength</code>: Distance between 2 peaks, in [m]</li> <li><code>wavespeed</code>: Wave velocity in m/s. (velocity of translation of the peaks)</li> <li><code>direction</code>: Direction in degrees of the current disturbance</li> <li><code>shift</code>: : Offset on the wave timing, adimentional value between 0 and 2\u03c0</li> </ul>"},{"location":"XML_files/#agents-description","title":"<code>agents</code> description","text":"<p>Section required to populate the simulation at initialization with agents. <code>agents</code> can contain a list of types, arbitrarelry named. For conventions use <code>agent_type</code>, <code>agent_type2</code> etc. Each <code>agent_type</code> must contain:</p> <ul> <li><code>description</code>: Path to agent xml. Either global or local path can be used.</li> <li><code>name</code>: Name prefix used by all agent of this type, inserted in this section. </li> <li><code>state</code>: 4xN matrix. The state is used to define the initial position of each agent.<ul> <li>1 line : position [x,y,z] in [m], heading in [degree]</li> <li>Each new line adds 1 extra Agent to the simulation</li> </ul> </li> </ul> <p>Example of state</p> <pre><code>    &lt;state&gt;\n        &lt;!-- x, y, z, psi --&gt;\n        0.0  0.0  10.0  10.0\n        2.0  0.0  8.0  180.0\n    &lt;/state&gt;\n</code></pre> <p>2 Agents, Agent 1 placed on [0,0,10] heading 10 degree North, Agent 2 placed in [2,0,8] heading South. </p>"},{"location":"XML_files/#seed-and-use-of-randomness-pipeline","title":"<code>seed</code> and use of randomness pipeline","text":"<p>The seed value is an optional value. It is defined as an integer value. If not specified the random generator is reinitialized at each start of the simulation, which result on a different sequence of random values at each run. If specified, then all random based event in the simulation will be tied to the seed value, and provvided no variation of the simulation parameters, will return consistent return at repeated runs. The seed is inherited from the simulation to the agents added in <code>agents</code>. </p>"},{"location":"agent/","title":"Agent Class Documentation","text":"<p>The Agent class models an underwater autonomous agent with configurable dynamics, control schemes, and noise effects. It supports heading, depth, and planar motion control, with options for direct force, velocity, and waypoint commands.  Initialization of the various instances of <code>Agent</code> are autonmatically created and initializated from the <code>Simulator</code> class. It is however possible to create independent instances and add the to the simulation with the <code>Simulator.add</code> method.</p> <p>The core use of the class, from the user perspective, are the Command Interfaces described below. see Command Interfaces</p>"},{"location":"agent/#overview","title":"Overview","text":"<ul> <li>Each agent is uniquely identified by its name.</li> <li>The class loads physical and control parameters from an XML configuration file.</li> <li>It simulates the sensor feedback, directely invloved in the payload, with optional noise.</li> <li>The internally processed sensors feedback are, with respect of the control scheme adopted: depth, heave speed, heading, yawrate, position, velocity, thruster force output. </li> <li>Multiple control schemes are available for heading, depth, and planar motion.</li> <li>Commands can be issued in terms of forces, velocities, positions, heading, depth, or yawrate.</li> </ul>"},{"location":"agent/#initialization","title":"Initialization","text":"<pre><code>Agent(\n    name: str,\n    initialPosition: array-like = [0.0, 0.0, 0.0],\n    initialHeading: float = 0.0,\n    agent_xml: str = \"default.xml\",\n    rng: int | None = None\n)\n</code></pre> <p>Parameters:</p> <ul> <li>name (str): Unique identifier for the agent.</li> <li>initialPosition (list | tuple | np.ndarray, size 3): Initial [x, y, z] position. Defaults to [0, 0, 0].</li> <li>initialHeading (float): Initial heading in degrees (0 = North, positive clockwise). Defaults to 0.0.</li> <li>agent_xml (str): XML file defining agent parameters. Defaults to \"default.xml\".</li> <li>rng (int | None): Random seed for measurement noise. If not given, an unseeded RNG is used.</li> </ul> <p>Example:</p> <pre><code>from SwarmSwIM import Agent\nA1 = Agent(name=\"A1\", initialPosition=[0, 0, -5], initialHeading=90.0, agent_xml = \"myagent.xml\")\n</code></pre>"},{"location":"agent/#key-attributes","title":"Key Attributes","text":"<ul> <li>pos (np.ndarray): Current 3D position [x, y, z].</li> <li>psi (float): Current heading (degrees).</li> <li>yawrate (float): Current yawrate (deg/s).</li> <li>measured_depth, measured_heading, measured_pos: Noisy sensor measurements.</li> <li>cmd_depth, cmd_heading, cmd_planar, cmd_local_vel, cmd_forces: Current control commands.</li> <li>planar_control, heading_control, depth_control: Control modes loaded from XML or set via commands.</li> <li>massMatrix, linear_damping, quadratic_damping: Dynamic parameters.</li> </ul>"},{"location":"agent/#simulation-cycle","title":"Simulation Cycle","text":""},{"location":"agent/#tick","title":"tick()","text":"<p>Advances the agent state by one simulation step:</p> <ol> <li>Updates sensor feedback with noise.</li> <li>Updates heading.</li> <li>Updates depth.</li> <li>Updates planar motion.</li> </ol> <p>Example:</p>"},{"location":"agent/#control-modes","title":"Control Modes","text":"<p>Depth Control:</p> <ul> <li>ideal: Instant correction.</li> <li>step: Incremental correction with fixed step size (constant speed, no overshoot). </li> <li>proportional: Proportional controller with threshold limits.</li> <li>heave: Direct controlled vertical velocity.</li> </ul> <p>Heading Control:</p> <ul> <li>ideal: Instant correction.</li> <li>step: Incremental correction with step size. (constant yaw rate, no overshoot)</li> <li>proportional: Pure Proportional controller with limit.</li> <li>yawrate: Direct yawrate control.</li> </ul> <p>Planar Control:</p> <ul> <li>ideal: Instant correction.</li> <li>step: Incremental waypoint tracking. Assumes constant planar translation. Unaffected by agent heading.</li> <li>local_velocity: Body-frame velocity commands, velocity compared to the surronding waterflow (The actual velocity is then affected by the additional translation of the currents, use this mode if the velocity contrlo is based on flow sensors or purerly model based).</li> <li>inertial_velocity: Body-frame velocity commands with current compensation. Makes best effort to mantain the velocity indicated, with respect to an inertial reference frame. Whithin the limits indicated fully compensaates for currents. Use when emulating feedback based on DLV or INS.</li> <li>local_forces: Force-based dynamics with damping and added mass. USe input as Body-frame force vector</li> </ul>"},{"location":"agent/#command-interfaces","title":"Command Interfaces","text":""},{"location":"agent/#set_forceheadingdepthforcenewtonnone-headingdegreesnone-depthmetersnone","title":"set_ForceHeadingDepth(forceNewton=None, headingDegrees=None, depthMeters=None)","text":"<p>Control planar force, heading, and depth simultaneously.</p> <p>Example:</p> <pre><code>A1.set_ForceHeadingDepth(forceNewton=[5., 0.], headingDegrees=45, depthMeters=10)\n</code></pre>"},{"location":"agent/#set_positionheadingpositionmeters-headingdegreesnone","title":"set_PositionHeading(positionMeters, headingDegrees=None)","text":"<p>Move to a target position with optional heading. If positionMeters has 3 values, depth is updated as well.</p> <p>Example:</p> <pre><code>A1.set_PositionHeading([10., 5.], headingDegrees=90)\n</code></pre>"},{"location":"agent/#set_forcecmdforcenewton-enforcefalse","title":"set_ForceCmd(forceNewton, enforce=False)","text":"<p>Direct force command in body frame. If enforce=True, sets planar_control = \"local_forces\".</p> <p>Example:</p> <pre><code>A1.set_ForceCmd([2., 0.], enforce=True)\n</code></pre>"},{"location":"agent/#set_velocitycmdvelocity-modenone","title":"set_VelocityCmd(velocity, mode=None)","text":"<p>Velocity command in body frame. mode can be \"local_velocity\" or \"inertial_velocity\".</p> <p>Example:</p> <pre><code>A1.set_VelocityCmd([1., 0.], mode=\"local_velocity\")\n</code></pre>"},{"location":"agent/#set_waypointcmdwaypoint-modenone","title":"set_WaypointCmd(waypoint, mode=None)","text":"<p>Waypoint command for planar position. mode can be \"ideal\" or \"step\".</p> <p>Example:</p> <pre><code>A1.set_WaypointCmd([5., 5.], mode=\"step\")\n</code></pre>"},{"location":"agent/#set_headingheadingdegrees-modenone","title":"set_Heading(headingDegrees, mode=None)","text":"<p>Heading command. Set desired heading in Degrees (NED) mode can be \"ideal\", \"step\", or \"proportional\".</p> <p>Example:</p> <pre><code>A1.set_Heading(180., mode=\"proportional\")\n</code></pre>"},{"location":"agent/#set_yawrateyawrate-enforcefalse","title":"set_Yawrate(yawrate, enforce=False)","text":"<p>Yawrate command. Set desired Yawrate in Degrees/second (NED) If enforce=True, sets heading_control = \"yawrate\".</p> <p>Example:</p> <pre><code>A1.set_Yawrate(10., enforce=True)\n</code></pre>"},{"location":"agent/#set_depthdepthmeters-modenone","title":"set_Depth(depthMeters, mode=None)","text":"<p>Depth command. Depth in meters, positive is down (NED) mode can be \"ideal\", \"step\", or \"proportional\".</p> <p>Example:</p> <pre><code>A1.set_Depth(20., mode=\"step\")\n</code></pre>"},{"location":"agent/#set_heaveheave-enforcefalse","title":"set_Heave(heave, enforce=False)","text":"<p>Heave (vertical velocity) command. Heave in meters/seconds, positive is down (NED) If enforce=True, sets depth_control = \"heave\".</p> <p>Example:</p> <pre><code>A1.set_Heave(0.5, enforce=True)\n</code></pre>"},{"location":"agent/#noise-simulation","title":"Noise Simulation","text":"<ul> <li>Each measurement can be affected by Gaussian noise.</li> <li>Noise parameters (e_depth, e_heading, e_position, etc.) are loaded from the XML.</li> <li>Errors are applied via emulate_error(value, error).</li> </ul>"},{"location":"agent/#notes","title":"Notes","text":"<ul> <li>The XML configuration file defines dynamics, damping, control parameters, and noise models.</li> <li>Depth is positive downwards (NED convention).</li> <li>Heading follows NED convention (0\u00b0 = North, increasing clockwise).</li> </ul>"},{"location":"create_new/","title":"Create a new simulation","text":"<p>Previous: To install</p>"},{"location":"create_new/#setup","title":"Setup","text":"<p>In order to create a new simulation is recommended to create a dedicated folder (separate from the installation folder, is installed from Source).</p> <p>For this example we will call it mysim</p> <pre><code>mkdir mysim &amp;&amp; cd mysim\n</code></pre> <p>Within the folder run the following shortcut:</p> <pre><code>SwarmSwIM create_new\n</code></pre> <p>Should output:</p> <pre><code>$ Initiated SwarmSwIM env templates in .\n</code></pre> <p>In windows or some python Env it ma be possible that the shortcut does not work, you can still refer to the script by running:</p> <pre><code>python3 -m SwarmSwIM.utility.cli create_new\n</code></pre> <p>Test by running the automatically created example:</p> <pre><code>python3 example.py\n</code></pre>"},{"location":"create_new/#create-a-new-script","title":"Create a new script","text":"<p>We will ignore <code>example.py</code> and create a brand new script to run our simulation Create a new file <code>my_first_sim.py</code></p> <pre><code># Import the Simulator\nfrom SwarmSwIM import Simulator\n\nPERIOD = 0.05 \n\n# Start a Simulator instance with a 0.05 s period\nS = Simulator(PERIOD)\n\n# define function describing all actions in a simulation step\ndef cycle():\n    # run a simulation step\n    events = S.tick()\n    # print step events\n    print(events)\n\n# Execute 100 simulation steps (5 seconds)\nfor i in range(100):\n    cycle()\n</code></pre> <p>This is the most basic simulation. </p> <pre><code>S = Simulator(PERIOD)\n</code></pre> <p>Starts a new simulation object with a certain timestep (mandatory field). By default the <code>Simulator</code> will search for <code>simualtion.xml</code> in the script folder. the user can specify a specific <code>sim_xml</code> as a path (either relative or absolute) to specify a different xml file to be used. Details of the <code>Simulator</code> class are in Simulator.</p> <p>We created a function called <code>cycle</code> that contains all the actions happening in a single simulation step.</p> <pre><code>events = S.tick()\nprint(events)\n</code></pre> <p>Advances the simulation forward of one period. events is a dictionary collecting all plugins events. Currenty no plugin has been added, as such the event dictionary is empty.</p> <p>Finally we run the simulation for 100 steps:</p> <pre><code>for i in range(100):\n    cycle()\n</code></pre> <p>The result is that we are printing an empty dictionary at each step, as the is no plugin event.</p> <p>Let's print somenthing more useful: in this simulation the agents are named <code>A01</code> and <code>A02</code>, the naming can be controlled in the simulator xml, later explained.</p> <p>To output the position of <code>A01</code> lets change the print to:</p> <pre><code>print(S['A01'].pos)\n</code></pre> <p>We will now see a series of 3-elements arrays:</p> <pre><code>[0. 0. 1.]\n</code></pre> <p>Those are the x, y, z position of <code>A01</code> at each step.</p> <p>In the next page, how to Set a 2d Visualized</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#simulation-example","title":"Simulation Example","text":"<pre><code>from SwarmSwIM import Simulator, CNNDetection\nTIME_STEP = 1 / 24  # Simulation time step in seconds\n\n# Initialize the simulator with the chosen time step\nS = Simulator(TIME_STEP)\n\n# Initialize a sensor model (e.g., CNN-based detection)\nDetection = CNNDetection()\n\n# Run the simulation until a specific condition is met\nfor i in range(1000):\n    S.tick()         # Progress the simulation by one time step\n    Detection(S)     # Apply detection on the current state of the simulator, return names of agents activated\n\n</code></pre> <p>This code runs the simulator in discrete steps until the specified condition is met. Note that the simulator does not run in real time; it iterates through each time step as quickly as possible. This setup is particularly useful for post-analysis and machine learning applications, where real-time processing is not required, and fast iteration are preferrable.</p>"},{"location":"getting_started/#minimal-animation","title":"Minimal animation","text":"<p>The animator2D provides a simple representation of the agents on the planar position and heading of each agent. Within comutational capabilites of the hosting machine and simulation complexity, the animator will run the simulation in real-time. A code example of the minimal animation can be found in the file <code>example2Danimation.py</code>.</p> <p>With the Package installed, from the SwarmSwIM folder, launch the example:</p> <pre><code>python3 -m SwarmSwIM.example2Danimation\n</code></pre>"},{"location":"installation/","title":"How To install SwarmSwIM","text":""},{"location":"installation/#default-installation","title":"Default installation","text":"<p>SwarmSwIM is a standard python package. For users that are not interested in adding or modifuing the code, it is suggested to install it as:</p> <pre><code>git clone https://github.com/save-xx/SwarmSwIM.git\n</code></pre> <p>This will install SwarmSwIM in your standard packages folder, which should be in your pythonpath.  You can quickly test it by opening a python IDE and typing</p> <pre><code>import SwarmSwIM\n</code></pre>"},{"location":"installation/#developer-installation-install-from-source","title":"Developer installation (Install from Source)","text":"<p>In order to have direct access to the codebase, set modifications, add or develop additional plugins it is necessary to setup a developer installation.  To install from source, create a folder where to save the source files, then clone the repository.</p> <pre><code>mkdir swsw_dev &amp;&amp; cd swsw_dev\ngit clone https://github.com/save-xx/SwarmSwIM.git\n</code></pre> <p>Enter the SwarmSwIM folder and use pip to install it in editable mode</p> <pre><code>cd SwarmSwIM/\npip install -e .\n</code></pre> <p>To run an isolated python vistual envrioment (using venv):</p> <pre><code># 1. Create your project folder and enter it\nmkdir swsw_dev &amp;&amp; cd swsw_dev\n\n# 2. Clone the repo\ngit clone https://github.com/save-xx/SwarmSwIM.git\n\n# 3. Create a virtual environment named \"swsw\"\npython3 -m venv swsw\n</code></pre> <p>Activate the virtual envrioment + On Linux / macOS:</p> <pre><code>source swsw/bin/activate\n</code></pre> <ul> <li>On Windows (PowerShell):</li> </ul> <pre><code>swsw\\Scripts\\Activate.ps1\n</code></pre> <p>Enter the cloned folder and Install SwarmSwIM in editable mode inside the swsw venv</p> <pre><code>cd SwarmSwIM/\npip install -e .\n</code></pre>"},{"location":"installation/#quick-test-installation","title":"Quick test installation","text":"<p>To test all the system installed and works correctly, run the example script From terminal</p> <pre><code>python3 -m SwarmSwIM.example\n</code></pre> <p>A windows should appear showcasing a 2D represntation</p> <p>You can now create a new simulation </p>"},{"location":"setVisualizer/","title":"Setting a Visualize 2D simualtion","text":"<p>In create new we have seen how to set a basic simulation.</p> <p>The basic setting has no visual interface, nor it runs in real time, which doen not allow for human interpretation. For this reason SwarmSwIM offers a 2D Visualizer plugin. The example.py is an implementation of the visualizer. </p> <p>lets create a new file: <code>my_first_animation.py</code>. We will use the <code>example.py</code> as template, and remove of the extra plugins and elements</p> <pre><code># my_first_animation.py\n\nfrom SwarmSwIM import Simulator\nfrom SwarmSwIM import Visualizer2D\n\nPERIOD = 0.05 \n\n# Start a Simulator instance with a 0.05 s period\nS = Simulator(PERIOD)\n\n# define cycle function\ndef cycle():\n    # spin the simulation\n    events = S.tick()\n    # print all events of the step\n    print(events)\n    # execute a command\n    S['A01'].set_ForceCmd(0.1)\n    S['A02'].set_ForceCmd(0.1)\n\n# ==============================\n# set 2D real time visualization\n# ==============================\n\n# define proprieties for visualization\nproperties = {\n    \"bg_color\": 'w', # background color (white)\n    \"grid\": True, # add grid visualization\n    \"color_by_type\": False, # set legend - False for individual names True for naming by type\n    \"record\": False, # creade video recording\n    }\n\n# create visualizer\nvisualizer = Visualizer2D(S, cycle, properties=properties)\n# runs simulation inside the visualizer\nvisualizer.run()\n</code></pre> <p>First we import a new element with:</p> <pre><code>from SwarmSwIM import Visualizer2D\n</code></pre> <p>This imports the visualization plugin</p> <p>As before we initialize the simulator:</p> <pre><code>PERIOD = 0.05 \n# Start a Simulator instance with a 0.05 s period\nS = Simulator(PERIOD)\n</code></pre> <p>The way the visualizer work, it requires the execution cycle to be defined in a function (<code>cycle</code>), with no arguments and no output. the cycle function must contain the <code>tick()</code> execution, plus any user defined logic.</p> <pre><code>def cycle():\n    # spin the simulation\n    events = S.tick()\n    # print all events of the step\n    print(events)\n    # execute a command\n    S['A01'].set_ForceCmd(0.1)\n    S['A02'].set_ForceCmd(0.1)\n</code></pre> <p>In this case we add a force command and apply to the 2 agents. more details on setting a command in </p> <p>Finally we define the visualizer. the visualizer takes 2 mandatory parameters, the Simulator instance and the callable of the cycle fucntion (function name without parenthesys). Additionally a dictionay can be passed to define the visual aspect of the Visualizer</p> <pre><code># define proprieties for visualization\nproperties = {\n    \"bg_color\": 'w', # background color (white)\n    \"grid\": True, # add grid visualization\n    \"color_by_type\": False, # set legend - False for individual names True for naming by type\n    \"record\": False, # creade video recording\n    }\n\n# create visualizer\nvisualizer = Visualizer2D(S, cycle, properties=properties)\n</code></pre> <p>In this example the propieties set the baground color and grid to be on. the legend is set so that each agent is represented individually (instead of by groups), and no video recording is saved.</p> <p>to run the simulation we execute run:</p> <pre><code>visualizer.run()\n</code></pre> <p>Try to run the script. A window should appear to show the top view representation of the system. and it should look as the following:</p> <p> </p> <p>In the terminal you will see printed empty dictionaries:</p> <pre><code>{}\n{}\n{}\n...\n</code></pre> <p>This is because the Visualizer produces no output.</p>"},{"location":"setVisualizer/#setting-a-background-image","title":"Setting a background image","text":"<p>ADD documentation</p>"},{"location":"setVisualizer/#test-yourself","title":"Test yourself","text":"<p>For yourself: try changeing background color in <code>bg_color</code>, set the legent to <code>\"color_by_type\": True</code>, and run with <code>\"record\": True</code> to save a mp4 reconding of the animation.</p> <p>Next, how to set your simulation envrioment</p>"},{"location":"set_simulation_xml/","title":"set simulation envrioment (XML)","text":""}]}