{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Agent/","title":"Agent","text":"<p>The Agent class contains all the information relative to a single agent in the simulation. The various instances of the agent classes </p> <p>SwarmSwIM.Agent (name, Dt= 0.1, initialPosition= np.array([0.0,0.0,0.0]), initialHeading = 0.0, agent_xml= \"default.xml\", rng= None)</p>"},{"location":"Agent/#parameters","title":"Parameters","text":"<ul> <li>name: (string) <ul> <li>Unique name of the agent added. Mandatory field</li> </ul> </li> <li>Dt (float) <ul> <li>Simulation interval in seconds. Overwritten by simulator. Default 0.0.</li> </ul> </li> <li>initialPosition (array-like[x,y,z]) <ul> <li>initial position of the agent in the world, NED coordinated. Default [0,0,0].</li> </ul> </li> <li>initialHeading (float) <ul> <li>initial heading of the agent. NED coordinates. Default 0.0 (North).</li> </ul> </li> <li>agent_xml (string) <ul> <li>Local path to the xml file describing the agent settings. Default is \"default.xml\"</li> </ul> </li> <li>rng (int or None)<ul> <li>Seed for the generation of the random generation, normal use is to hereditate the seed from the simulation. If None (default) a the seed is randomized.</li> </ul> </li> </ul>"},{"location":"Agent/#attributes","title":"Attributes","text":"<ul> <li>measured_depth: (float) <ul> <li>Measured estimated depth used in depth control</li> </ul> </li> <li>measured_heading: (float) <ul> <li>Measured estimated heading used in heading control</li> </ul> </li> <li>measured_pos: (list[x,y]) <ul> <li>Measured estimated position used in position control </li> </ul> </li> <li>cmd_depth: (float) <ul> <li>get/set desired depth in meters. Only when depth_control is ideal, step, proportional.</li> </ul> </li> <li>cmd_heave: (float) <ul> <li>get/set desired heave velocity. Only when depth_control is heave.</li> </ul> </li> <li>cmd_heading: (float) <ul> <li>get/set desired heading in degrees. Only when heading_control is ideal, step, proportional.</li> </ul> </li> <li>cmd_yawrate: (float) <ul> <li>get/set desired rotational yaw rate velocity. Only when depth_control is yawrate.</li> </ul> </li> <li>cmd_planar: (numpy.array[x,y]) <ul> <li>get/set planar desired coordinates. Only when planar_control is ideal or step.</li> </ul> </li> <li>cmd_local_vel: (array like or float) <ul> <li>get/set desired surge and sway velocity [x,y] in body frame. Only when planar_control is local_velocity. If set float, assumes sway=0.</li> </ul> </li> <li>cmd_forces: (array like or float) <ul> <li>get/set desired surge and sway forces in body frame. Only when planar_control is local_forces. If set float, assumes sway=0.</li> </ul> </li> <li>internal_clock: (float) <ul> <li>internally measured time, affected by clock drift.</li> </ul> </li> </ul> <p>TODO 'e_depth','e_heave','e_heading','e_yawrate','e_position','e_local_vel','e_inertial_vel', 'e_local_force'</p>"},{"location":"Agent/#additional-attributes","title":"Additional Attributes","text":"<p>Based on addon sensors, the class can collected additional attributes used by the relative plugins</p> <ul> <li>NNDetector: (dictionary) <ul> <li>results obtained since last detection event. Each key is the name of a detected agent, and the item associated is a list of [distance, relative horizontal angle, relative vertical angle]. A special key named time_lapsed contains the value of the time interval since last detection. See <code>NNDetector</code>.</li> </ul> </li> </ul>"},{"location":"Agent/#methods","title":"Methods","text":"<ul> <li> <p>cmd_fhd(force,heading,depth)-&gt;None: </p> <ul> <li>Set desired command as force (float or array-like[x,y]), heading (float), depth (float). </li> </ul> </li> <li> <p>cmd_xyz_phi(position,heading)-&gt;None: </p> <ul> <li>Set desired waypoint (np.array[3]) and heading (float)</li> </ul> </li> </ul>"},{"location":"Agent/#examples","title":"Examples","text":"<pre><code># Import The Simulator from SwarmSwIM\nfrom SwarmSwIM import Simulator, Agent\n\n# Generate a simulation object, set the time step to 1/30 sec (30 Hz)\nTIME_STEP = 1.0 / 30\nsim = Simulator(TIME_STEP)\n\n# Create an additional agent, type default, at initial position x0 and heading psi0\nx0 = [2.0, 3.0, 12.0]\npsi0 = 30\nnew_agent = Agent('nemo', TIME_STEP, initialPosition= x0 , initialHeading= psi0)\n\n# set an initial command to the new agent, as surge force (1N), heading (90 degree), and depth (10m)\nnew_agent.cmd_fhd(1.0, 90.0, 10.0)\n\n# Add new agent to simulation\nsim.add(new_agent)\n\n# Run 100 seconds of simulation\nfor ist in range(3000):\n    # Print new agent name and position of simulation evey 300 ist (10 sec)\n    if ist%300==0: print(f'{sim.agents[-1].name}: pos {sim.agents[-1].measured_pos}')\n    # advance the simulation foward of one TIME_STEP seconds\n    sim.tick()\n</code></pre>"},{"location":"CNNDetection/","title":"CNNDetection","text":"<p>The <code>CNNDetection</code> class is an optional sensor plugin designed to emulate the output of a Convolutional Neural Network (CNN) detector. It simulates the detection and localization of neighboring agents by estimating their positions and headings. This plugin operates as a global sensor, meaning it has access to the full environment state to generate its output.</p> <p>SwarmSwIM.sensors.CNNDetection (rnd = None, visibility_model = None)</p>"},{"location":"CNNDetection/#parameters","title":"Parameters","text":"<ul> <li>rnd: (numpy.random.generator or None) Default None<ul> <li>Initializes the random number generator. If set to <code>None</code>, a new generator will be created. Otherwise, the provided generator will be used. The intended usage is to inherit the generator from the <code>Simulator</code>, ensuring consistent and reproducible behavior across components.</li> </ul> </li> </ul> <p>(deprectated remove) - visibility_model: (string) Default None      * Define model used to determine the distance-based probability of detection. <code>None</code>, and <code>linear</code>. In  <code>None</code> all detection are succesfull if contained in the defined Field of View. In <code>linear</code> the probability function is defined as a splitwise linear fuction of the distance. </p>"},{"location":"CNNDetection/#methods","title":"Methods","text":"<ul> <li><code>__call__</code>(Simulation)  -&gt;  list [string] <ul> <li>Calculates the detections of all agents involved in the simulations, outputs the lists of the agents names that recived an updated in the call. The input is the <code>Simulation</code> instance. Note that the method already optimizes on the udate rate, so that the relative pose clculations are only executed as needed.  This method alters and stores the relative informations in each <code>Agent</code> instance withing the <code>NNDetector</code> atturibute (see Example).</li> </ul> </li> </ul>"},{"location":"CNNDetection/#agentnndetector","title":"<code>Agent.NNDetector</code>","text":"<p>The <code>Agent.NNDetector</code> is an optional <code>Agent</code> attrubute which is manipulated by the <code>CNNDetection</code> in order to store the detection informations. Specifically it is a dictionary with the following proprieties:  - a special key <code>time_lapsed</code> stores the lapsed time since the last detection activation.  - a key with the name of each agent sucessfully detected in the last detection structures as a list of three flloats:     - Radial relative distance [m]     - Planar angle Alpha [degree]. Angle on the horizontal plane, with x axis (0 degree) the heading of the observing Agent.     - Elevation angle Beta [degree]. Angle measured from the horizontal plane</p> <p>The values presented already implement the measuraments noises as defined in the Agent XML description.</p>"},{"location":"CNNDetection/#examples","title":"Examples","text":"<pre><code># Import The Simulator from SwarmSwIM\nfrom SwarmSwIM import Simulator, Agent\nfrom SwarmSwIM import CNNDetection\n\n# Generate a simulation object, set the time step to 1/30 sec (30 Hz)\nTIME_STEP = 1.0 / 30\nsim = Simulator(TIME_STEP)\n# Initiate detection\nDetection = CNNDetection()\n\nfirst_agent_name = sim.agents[0].name\n\n# Run 100 seconds of simulation\nfor ist in range(3000):\n    # advance the simulation foward of one TIME_STEP seconds\n    sim.tick()\n    detection_upd_names = Detection(sim)\n    # print resulting detection for the first agent, if it has recived an update\n    if first_agent_name in detection_upd_names:\n        new_detection = sim.agents[0].NNDetector\n        for key in new_detection:\n            if key=='time_lapsed': continue\n            print(f' time: {sim.time:.2f}', end=\"\")\n            print(f'    {key} : ',end=\"\") \n            print(f'[ dist: {new_detection[key][0]:.2f} ',end=\"\") \n            print(f'alpha: {new_detection[key][1]:.2f} ',end=\"\") \n            print(f'beta: {new_detection[key][2]:.2f} ]')\n</code></pre>"},{"location":"Home/","title":"SwarmSwIM wiki","text":"<p>Useful links: - Parameters: Description of the parameters and methods of the classes, and fuction of this package.  - setup XML files: Description of the files defining the simulation and agents charatersitics</p>"},{"location":"Parameters/","title":"Parameters","text":""},{"location":"Parameters/#attributes-and-methods","title":"Attributes and Methods","text":"<p>Description of the simulator classes and associated attributes and methods</p> <ul> <li>Simulator: Generate the core simulation.</li> <li>Agent: Generate an instance of a simulated agent. </li> </ul>"},{"location":"Simulator/","title":"Simulator","text":"<p>The <code>Simulator</code> class holds the primary tool to run a simulation. A single instance of the class is required for a simulation run. If the simulation is run with support of the UE5 Api of ROS bridging, The API or ROS bridge will handle the creation and setting of the <code>Simulation</code> class instance.</p> <p>SwarmSwIM.Simulator (timeSubdivision, sim_xml= \"simulation.xml\") Generate a simulation instance  </p>"},{"location":"Simulator/#parameters","title":"Parameters:","text":"<ul> <li>timeSubdivision:  (float) <ul> <li>Simulation interval in seconds (mandatory)  </li> </ul> </li> <li>sim_xml: (string) <ul> <li>Local or Global path to the xml file describing the simulation settings. Default is \"simulation.xml\" The setting provvides the addition of all Agents and all current effects. </li> </ul> </li> </ul>"},{"location":"Simulator/#attributes","title":"Attributes:","text":"<ul> <li>time: (float) <ul> <li>Current enlapsed time in seconds</li> </ul> </li> <li>rnd: (random.generator) <ul> <li>Random generator object associated to this specific simulation. </li> </ul> </li> <li>agents: (list of Agents) <ul> <li>List of the actively simulated agents objects</li> </ul> </li> <li>environment: (dictionary) <ul> <li>Collection of all current parameters. See Description avaiable option. This attribute is precompiled by the sim_xml file.</li> </ul> </li> <li>states: (dictionary name: np.array [x,y,z]) <ul> <li>Position of each agent in the simulation, collected by agent name as key </li> </ul> </li> </ul>"},{"location":"Simulator/#methods","title":"Methods:","text":"<ul> <li>add ( * args) -&gt; None: add one or more agents to the simulation. <ul> <li>args: one or more Agent object</li> </ul> </li> <li> <p>remove ( * args) -&gt; None: remove, if present, one or more agents to the simulation. </p> <ul> <li>args: one or more Agent object in agents.  </li> </ul> </li> <li> <p>tick( ) -&gt; None: move the simulation foward of the interval indicated in Dt</p> </li> <li> <p>rel_pos (Agent1, Agent2) -&gt; numpy.array: return the istantaneous position vector of Agent2 respect to Agent1.</p> <ul> <li>Agent1: Agent object</li> <li>Agent2: Agent object</li> </ul> </li> <li> <p>acoustic_range (Agent1, Agent2) -&gt; float: return the distance vector of Agent2 respect to Agent1, considering acoustic delay, including measurament errors.</p> <ul> <li>Agent1: Agent object (reciver)</li> <li>Agent2: Agent object (sender)</li> </ul> </li> <li> <p>OWTT_acoustic_range (Agent1, Agent2) -&gt; float: return the distance vector of Agent2 respect to Agent1, considering acoustic delay, , including measurament errors and One way clock drift error.</p> <ul> <li>Agent1, Agent object (reciver)</li> <li>Agent2: Agent object (sender)</li> </ul> </li> <li> <p>doppler (Agent1, Agent2, msg_dt= 1.0) -&gt; float: return the value of doppler velocity of Agent2 measured by agent1 on an incoming communication, including measurament errors.</p> <ul> <li>Agent1, Agent object (reciver)</li> <li>Agent2: Agent object (sender)</li> </ul> </li> </ul>"},{"location":"Simulator/#examples","title":"Examples","text":"<p>Following a minimalist example of the use of the <code>Simulator</code></p> <pre><code># Import The Simulator from SwarmSwIM\nfrom SwarmSwIM import Simulator\n\n# Generate a simulation object, set the time step to 1/30 sec (30 Hz)\nTIME_STEP = 1.0 / 30\nsim = Simulator(TIME_STEP)\n\n# Run 100 seconds of simulation\nfor ist in range(3000):\n    # Print current time of simulation evey 300 ist (10 sec)\n    if ist%300==0: print(f'{sim.time:.2f}')\n    # advance the simulation foward of one TIME_STEP seconds\n    sim.tick()\n</code></pre>"},{"location":"Simulator/#environment-attrubute-description","title":"<code>environment</code> attrubute description","text":"<p>The Simulator.environment attribute is a dictionary containing all the parameters that globally characterize the simulation. This attribute is fully populated during initialization and reflects the content of the simulation XML file. The preferred usage is to rely on the XML file for all parameter definitions. However, in certain scenarios, it may be useful to modify specific parameters during the mission. Below is a description of the individual elements:</p> <p><code>seed</code> Integer value used as seed for the random generator, if not defined an new random seed is used at each launch. Changes ater launch have no effect to the simulation. </p> <p><code>is_uniform_current</code> Boolean, enables uniform currents</p> <p><code>uniform_current</code> Value of uniform current. (see XML sim for usage)</p> <p><code>is_noise_currents</code> Boolean, enables noise currents</p> <p><code>noise_currents_freq</code>, <code>noise_currents_intensity</code> Value of noise current. (see XML sim for usage)</p> <p><code>is_vortex_currents</code> Boolean, enables large vortex currents</p> <p><code>vortex_currents_density</code>, <code>vortex_currents_intensity</code>  Value of vortex current. (see XML sim for usage)</p> <p><code>is_global_waves</code> Boolean, enables global waves (only time dependant) currents</p> <p><code>global_waves</code> Contains a list of dictionaries, each defining a global wave. Each of such dictionay is structured as follows: - <code>amplitude</code> - <code>frequency</code> - <code>direction</code> - <code>shift</code> Details on the Vaules contained under each key are explained in XML sim.</p> <p><code>is_local_waves</code> Boolean, enables local waves (time and space dependant) currents</p> <p><code>local_waves</code> Contains a list of dictionaries, each defining a local wave. Each of such dictionay is structured as follows: - <code>amplitude</code> - <code>wavelength</code> - <code>wavespeed</code> - <code>direction</code> - <code>shift</code></p> <p>Details on the Vaules contained under each key are explained in XML sim.</p>"},{"location":"XML_files/","title":"Setup Files","text":"<p>The simulators refers to 2 types of file for setting up the simulations. Thhose files contain all the paramenter and charateristics that allow to personalize each simulatation as needed. The files are written in XML format.  The philosofy is to allow the content of the file to coexisit whitin a standard URDF file, describing a specific robot  (agent) or simulation. Practical application of this principle is still ongoing. </p>"},{"location":"XML_files/#agent-description","title":"Agent Description","text":"<p>The agent description file defines the charateristics of a type of agent. It is worth nothing that multiple types can coexist in a simulation, and multiple instances of the same type are also allowed. The agent description file is defined either at the initialization of an <code>Agent</code> instance or within the Simulation description file. If not specified the default.xml description provvided in this package is used instead. </p> <p>The Agent Description file need to have the <code>.xml</code> termination and XML format. It is structured as follows: </p> <pre>\nagent.xml \n\u2514\u2500\u2500 data  \n    \u251c\u2500\u2500 sim_agent\n    \u2514\u2500\u2500 sensors \n        \u251c\u2500\u2500 NNDetector\n        \u2514\u2500\u2500 Acoustic_Ranging\n</pre> <p><code>sim_agent</code> contains all the primary information regarding the agent, while <code>sensors</code> contains plug-in pecific charaterization parameters. It is worth noting that <code>sensor</code> can be populated even if those sensors are not imported in the simulation.</p>"},{"location":"XML_files/#sim_agent-description","title":"<code>sim_agent</code> description","text":"<p>The following parameters are tunable in the sim_agent section:</p>"},{"location":"XML_files/#inertia-and-drag","title":"Inertia and Drag","text":"<ul> <li><code>mass</code>: Dry mass of the agent in Kg</li> <li><code>added_mass</code>: 2x2 matrix of the added mass of the agent, referring to the [u,v] linear &amp; planar DoF (see Handbook of Marine Craft, Thor I. Fossen). Note that the convention used if for the diagonal element to be defined positive.</li> <li><code>quadratic_damping</code>, <code>linear_damping</code>: 2x2 matrixes referring to the linear and quatratic dumping due to hydrodynamic drag. Following the formula.           Note that the convention used if for the diagonal element to be defined negative.</li> </ul>"},{"location":"XML_files/#controls","title":"Controls","text":"<p>Following the controls schemes that can be directly emulated and associated parameters. It is worth nothing that all parameters can be popoulated. The simulator will require the control specifi parameters to be defined. the control type can also be altered during the simulation, thus the associated parameters specified in the xml for the new type of control will be adapted.</p> <p>Control - Depth - <code>depth_control</code>: type of control used. Options are \"ideal\", \"step\", \"proportional\", \"heave\" - <code>step_depth</code>: speed of ascend/descend in m/s when \"step\" is selected - <code>proportional_depth</code>: value of propotional control when \"proportional\" is selected. Input is depth error [m], output is heave velocity [m/s]. - <code>heave_limit</code>: Upper-Lower limit of heave velocity [m/s], when \"proportional\" is selected.</p> <p>Control - Heading - <code>heading_control</code>: type of control used. Options are \"ideal\", \"step\", \"proportional\", \"yawrate\" - <code>step_depth</code>: speed of rotation yawrate in degrees/s when \"step\" is selected - <code>proportional_depth</code>: value of propotional control when \"proportional\" is selected. Input is heading error [degrees], assuming shortest direction, output is yawrate velocity [degree/s]. - <code>yawrate</code>: Upper-Lower limit of yawrate velocity [degree/s], when \"proportional\" is selected.</p> <p>Control - Planar - <code>planar_control</code>: type of control used. Options are \"ideal\", \"step\", \"local_velocity\",\"inertial_velocity\", \"local_forces\" - <code>step_planar</code>: planar speed in m/s when \"step\" is selected - <code>vel_limit</code>: 2-values, repesenting the surge and sway [u,v] velocity limit that the agent can reach. Applyed when \"local_velocity\" or \"inertial_velocity\" is selected.</p>"},{"location":"XML_files/#errornoises","title":"Error/Noises","text":"<p>Error and noises of the feedbacks expected in the control schemes can be emulated defining the error parameters. Such noises are modelled as gaussian noise and bias added to the ground truth value and then applied as input in the control scheme. A generic noise is defined as: - <code>e_&lt;input&gt;</code> = bias, standard deviation  </p> <p>The noises input that can be defined are: - <code>e_depth</code> - <code>e_heave</code> - <code>e_heading</code> - <code>e_yawrate</code> - <code>e_position</code> - <code>e_local_vel</code> - <code>e_inertial_vel</code> - <code>e_local_force</code></p> <p>The exception is <code>clock_drift</code> which is defined as the drift of the internal clock as PPM</p>"},{"location":"XML_files/#simulation-description","title":"Simulation Description","text":"<p>Each simulation is defined by a single simulation.xml file. The file is specified in the initialization of the <code>Simulation</code> class, and contains all the instructions to also initialize the agents. If not defined the simulation.xml file in this package is used as default.  </p> <p>The simulation description file need to have the <code>.xml</code> termination and XML format. It is structured as follows: </p> <pre>\nagent.xml \n\u2514\u2500\u2500 data  \n    \u251c\u2500\u2500 environment_setup\n    |   \u251c\u2500\u2500 global_waves\n    |   \u2514\u2500\u2500 local_waves\n    \u251c\u2500\u2500 agents \n    |   \u2514\u2500\u2500 agent_type\n    \u2514\u2500\u2500 seed\n</pre>"},{"location":"XML_files/#environment_setup-description","title":"<code>environment_setup</code> description","text":"<p>The <code>environment_setup</code> stores all data relative to current and current disturbances affecting the agents kinematics in the simulation.</p> <p>Uniform constant current - <code>uniform_current</code> :2-Values defining the current component Direction North-East, value in m/s</p> <p>Localized current disturbances and noise - <code>noise_currents</code> :2-Values Frequency (Hz), and max Intensity (m/s) of the localized current affecting each agent. At a rate driven by the Frequency, a disturbance vector of magnitude 0 to Intensity (Random Uniform) and random direction is generated. At each instance the noise disturbance affecting an agent is the linear interpolation of the last and next disturbance vector over time.</p> <ul> <li><code>vortex_currents</code>: 2-Values. Density and Intensity. Density is an integer determining the number of the vorticosity centers each 100 meter square, while intensity is the value intensity [m/s] associated to the votex. The effective modelling is explained in [link required].</li> </ul>"},{"location":"XML_files/#global_waves","title":"global_waves","text":"<p>Time dependand space independent sinusoidal wave-like disturbance. <code>global_waves</code> can contain a list of entries with arbitrary names. for conventions use <code>wave1</code>, <code>wave2</code> etc. Eack <code>wave</code> mush contain:</p> <ul> <li><code>amplitude</code>: Peak current intensity in m/s</li> <li><code>frequency</code>: Wave frequency, time based, expressed in Hz</li> <li><code>direction</code>: Direction in degrees of the current disturbance</li> <li><code>shift</code>: Offset on the wave timing, adimentional value between 0 and 2\u03c0</li> </ul>"},{"location":"XML_files/#local_waves","title":"local_waves","text":"<p>Time and space dependand sinusoidal wave-like disturbance. <code>local_waves</code> can contain a list of entries with arbitrary names. For conventions use <code>wave1</code>, <code>wave2</code> etc. Eack <code>wave</code> mush contain:</p> <ul> <li><code>amplitude</code>: Peak current intensity in m/s</li> <li><code>wavelength</code>: Distance between 2 peaks, in [m]</li> <li><code>wavespeed</code>: Wave velocity in m/s. (velocity of translation of the peaks)</li> <li><code>direction</code>: Direction in degrees of the current disturbance</li> <li><code>shift</code>: : Offset on the wave timing, adimentional value between 0 and 2\u03c0</li> </ul>"},{"location":"XML_files/#agents-description","title":"<code>agents</code> description","text":"<p>Section required to populate the simulation at initialization with agents. <code>agents</code> can contain a list of types, arbitrarelry named. For conventions use <code>agent_type</code>, <code>agent_type2</code> etc. Each <code>agent_type</code> must contain:</p> <ul> <li><code>description</code>: Path to agent xml. Either global or local path can be used.</li> <li><code>name</code>: Name prefix used by all agent of this type, inserted in this section. </li> <li><code>state</code>: 4xN matrix. The state is used to define the initial position of each agent.<ul> <li>1 line : position [x,y,z] in [m], heading in [degree]</li> <li>Each new line adds 1 extra Agent to the simulation</li> </ul> </li> </ul> <p>Example of state</p> <pre><code>    &lt;state&gt;\n        &lt;!-- x, y, z, psi --&gt;\n        0.0  0.0  10.0  10.0\n        2.0  0.0  8.0  180.0\n    &lt;/state&gt;\n</code></pre> <p>2 Agents, Agent 1 placed on [0,0,10] heading 10 degree North, Agent 2 placed in [2,0,8] heading South. </p>"},{"location":"XML_files/#seed-and-use-of-randomness-pipeline","title":"<code>seed</code> and use of randomness pipeline","text":"<p>The seed value is an optional value. It is defined as an integer value. If not specified the random generator is reinitialized at each start of the simulation, which result on a different sequence of random values at each run. If specified, then all random based event in the simulation will be tied to the seed value, and provvided no variation of the simulation parameters, will return consistent return at repeated runs. The seed is inherited from the simulation to the agents added in <code>agents</code>. </p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#simulation-example","title":"Simulation Example","text":"<pre><code>from SwarmSwIM import Simulator, CNNDetection\nTIME_STEP = 1 / 24  # Simulation time step in seconds\n\n# Initialize the simulator with the chosen time step\nS = Simulator(TIME_STEP)\n\n# Initialize a sensor model (e.g., CNN-based detection)\nDetection = CNNDetection()\n\n# Run the simulation until a specific condition is met\nfor i in range(1000):\n    S.tick()         # Progress the simulation by one time step\n    Detection(S)     # Apply detection on the current state of the simulator, return names of agents activated\n\n</code></pre> <p>This code runs the simulator in discrete steps until the specified condition is met. Note that the simulator does not run in real time; it iterates through each time step as quickly as possible. This setup is particularly useful for post-analysis and machine learning applications, where real-time processing is not required, and fast iteration are preferrable.</p>"},{"location":"getting_started/#minimal-animation","title":"Minimal animation","text":"<p>The animator2D provides a simple representation of the agents on the planar position and heading of each agent. Within comutational capabilites of the hosting machine and simulation complexity, the animator will run the simulation in real-time. A code example of the minimal animation can be found in the file <code>example2Danimation.py</code>.</p> <p>With the Package installed, from the SwarmSwIM folder, launch the example:</p> <pre><code>python3 -m SwarmSwIM.example2Danimation\n</code></pre>"}]}